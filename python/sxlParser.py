# Generated from sxl.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\62")
        buf.write("\u00d1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\3\2\3\2\3\2\6\2@\n\2\r\2\16\2A\3\2\3\2\3\3\3\3\3\3\6")
        buf.write("\3I\n\3\r\3\16\3J\3\3\3\3\3\4\3\4\3\4\3\4\5\4S\n\4\3\5")
        buf.write("\3\5\3\5\6\5X\n\5\r\5\16\5Y\3\5\3\5\3\6\3\6\3\6\6\6a\n")
        buf.write("\6\r\6\16\6b\3\6\3\6\3\7\3\7\3\7\3\7\5\7k\n\7\3\b\3\b")
        buf.write("\3\b\6\bp\n\b\r\b\16\bq\3\b\3\b\3\t\3\t\3\t\6\ty\n\t\r")
        buf.write("\t\16\tz\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\5")
        buf.write("\n\u0088\n\n\3\13\3\13\3\13\6\13\u008d\n\13\r\13\16\13")
        buf.write("\u008e\3\13\3\13\3\f\3\f\3\f\3\f\5\f\u0097\n\f\3\f\3\f")
        buf.write("\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\20\3\20\3")
        buf.write("\20\3\21\3\21\3\21\3\22\3\22\3\22\3\23\3\23\3\24\3\24")
        buf.write("\3\24\3\25\3\25\3\26\3\26\3\26\3\27\3\27\3\30\3\30\3\30")
        buf.write("\3\31\3\31\3\31\5\31\u00bf\n\31\3\32\3\32\3\32\3\33\3")
        buf.write("\33\3\33\3\34\3\34\3\34\5\34\u00ca\n\34\3\35\3\35\3\35")
        buf.write("\3\36\3\36\3\36\2\2\37\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write("\34\36 \"$&(*,.\60\62\64\668:\2\t\3\2,-\3\2\16\20\4\2")
        buf.write("\22\23//\3\2\25\36\4\2\22\22\')\4\2\16\20\"#\4\2\34\34")
        buf.write("&&\2\u00cd\2<\3\2\2\2\4E\3\2\2\2\6R\3\2\2\2\bT\3\2\2\2")
        buf.write("\n]\3\2\2\2\fj\3\2\2\2\16l\3\2\2\2\20u\3\2\2\2\22\u0087")
        buf.write("\3\2\2\2\24\u0089\3\2\2\2\26\u0092\3\2\2\2\30\u009a\3")
        buf.write("\2\2\2\32\u009d\3\2\2\2\34\u00a0\3\2\2\2\36\u00a3\3\2")
        buf.write("\2\2 \u00a6\3\2\2\2\"\u00a9\3\2\2\2$\u00ac\3\2\2\2&\u00ae")
        buf.write("\3\2\2\2(\u00b1\3\2\2\2*\u00b3\3\2\2\2,\u00b6\3\2\2\2")
        buf.write(".\u00b8\3\2\2\2\60\u00be\3\2\2\2\62\u00c0\3\2\2\2\64\u00c3")
        buf.write("\3\2\2\2\66\u00c9\3\2\2\28\u00cb\3\2\2\2:\u00ce\3\2\2")
        buf.write("\2<=\7\3\2\2=?\7\4\2\2>@\5\4\3\2?>\3\2\2\2@A\3\2\2\2A")
        buf.write("?\3\2\2\2AB\3\2\2\2BC\3\2\2\2CD\7\5\2\2D\3\3\2\2\2EF\7")
        buf.write("/\2\2FH\7\4\2\2GI\5\6\4\2HG\3\2\2\2IJ\3\2\2\2JH\3\2\2")
        buf.write("\2JK\3\2\2\2KL\3\2\2\2LM\7\5\2\2M\5\3\2\2\2NS\5\30\r\2")
        buf.write("OS\5\32\16\2PS\5\34\17\2QS\5\b\5\2RN\3\2\2\2RO\3\2\2\2")
        buf.write("RP\3\2\2\2RQ\3\2\2\2S\7\3\2\2\2TU\7\6\2\2UW\7\4\2\2VX")
        buf.write("\5\n\6\2WV\3\2\2\2XY\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z[\3\2")
        buf.write("\2\2[\\\7\5\2\2\\\t\3\2\2\2]^\7/\2\2^`\7\4\2\2_a\5\f\7")
        buf.write("\2`_\3\2\2\2ab\3\2\2\2b`\3\2\2\2bc\3\2\2\2cd\3\2\2\2d")
        buf.write("e\7\5\2\2e\13\3\2\2\2fk\5\30\r\2gk\5\32\16\2hk\5\16\b")
        buf.write("\2ik\5 \21\2jf\3\2\2\2jg\3\2\2\2jh\3\2\2\2ji\3\2\2\2k")
        buf.write("\r\3\2\2\2lm\7\7\2\2mo\7\4\2\2np\5\20\t\2on\3\2\2\2pq")
        buf.write("\3\2\2\2qo\3\2\2\2qr\3\2\2\2rs\3\2\2\2st\7\5\2\2t\17\3")
        buf.write("\2\2\2uv\7/\2\2vx\7\4\2\2wy\5\22\n\2xw\3\2\2\2yz\3\2\2")
        buf.write("\2zx\3\2\2\2z{\3\2\2\2{|\3\2\2\2|}\7\5\2\2}\21\3\2\2\2")
        buf.write("~\u0088\5\"\22\2\177\u0088\5&\24\2\u0080\u0088\5*\26\2")
        buf.write("\u0081\u0088\5.\30\2\u0082\u0088\5\62\32\2\u0083\u0088")
        buf.write("\5\64\33\2\u0084\u0088\58\35\2\u0085\u0088\5\24\13\2\u0086")
        buf.write("\u0088\5\30\r\2\u0087~\3\2\2\2\u0087\177\3\2\2\2\u0087")
        buf.write("\u0080\3\2\2\2\u0087\u0081\3\2\2\2\u0087\u0082\3\2\2\2")
        buf.write("\u0087\u0083\3\2\2\2\u0087\u0084\3\2\2\2\u0087\u0085\3")
        buf.write("\2\2\2\u0087\u0086\3\2\2\2\u0088\23\3\2\2\2\u0089\u008a")
        buf.write("\7\b\2\2\u008a\u008c\7\4\2\2\u008b\u008d\5\26\f\2\u008c")
        buf.write("\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008c\3\2\2\2")
        buf.write("\u008e\u008f\3\2\2\2\u008f\u0090\3\2\2\2\u0090\u0091\7")
        buf.write("\5\2\2\u0091\25\3\2\2\2\u0092\u0093\7/\2\2\u0093\u0094")
        buf.write("\7\4\2\2\u0094\u0096\5\36\20\2\u0095\u0097\5\30\r\2\u0096")
        buf.write("\u0095\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u0098\3\2\2\2")
        buf.write("\u0098\u0099\7\5\2\2\u0099\27\3\2\2\2\u009a\u009b\7\t")
        buf.write("\2\2\u009b\u009c\7\61\2\2\u009c\31\3\2\2\2\u009d\u009e")
        buf.write("\7\n\2\2\u009e\u009f\7*\2\2\u009f\33\3\2\2\2\u00a0\u00a1")
        buf.write("\7\13\2\2\u00a1\u00a2\7*\2\2\u00a2\35\3\2\2\2\u00a3\u00a4")
        buf.write("\7\f\2\2\u00a4\u00a5\t\2\2\2\u00a5\37\3\2\2\2\u00a6\u00a7")
        buf.write("\7\r\2\2\u00a7\u00a8\t\3\2\2\u00a8!\3\2\2\2\u00a9\u00aa")
        buf.write("\7\21\2\2\u00aa\u00ab\5$\23\2\u00ab#\3\2\2\2\u00ac\u00ad")
        buf.write("\t\4\2\2\u00ad%\3\2\2\2\u00ae\u00af\7\24\2\2\u00af\u00b0")
        buf.write("\5(\25\2\u00b0\'\3\2\2\2\u00b1\u00b2\t\5\2\2\u00b2)\3")
        buf.write("\2\2\2\u00b3\u00b4\7\37\2\2\u00b4\u00b5\5,\27\2\u00b5")
        buf.write("+\3\2\2\2\u00b6\u00b7\t\6\2\2\u00b7-\3\2\2\2\u00b8\u00b9")
        buf.write("\7 \2\2\u00b9\u00ba\5\60\31\2\u00ba/\3\2\2\2\u00bb\u00bf")
        buf.write("\7,\2\2\u00bc\u00bf\7-\2\2\u00bd\u00bf\7(\2\2\u00be\u00bb")
        buf.write("\3\2\2\2\u00be\u00bc\3\2\2\2\u00be\u00bd\3\2\2\2\u00bf")
        buf.write("\61\3\2\2\2\u00c0\u00c1\7!\2\2\u00c1\u00c2\t\7\2\2\u00c2")
        buf.write("\63\3\2\2\2\u00c3\u00c4\7$\2\2\u00c4\u00c5\5\66\34\2\u00c5")
        buf.write("\65\3\2\2\2\u00c6\u00ca\7,\2\2\u00c7\u00ca\7-\2\2\u00c8")
        buf.write("\u00ca\7*\2\2\u00c9\u00c6\3\2\2\2\u00c9\u00c7\3\2\2\2")
        buf.write("\u00c9\u00c8\3\2\2\2\u00ca\67\3\2\2\2\u00cb\u00cc\7%\2")
        buf.write("\2\u00cc\u00cd\5:\36\2\u00cd9\3\2\2\2\u00ce\u00cf\t\b")
        buf.write("\2\2\u00cf;\3\2\2\2\17AJRYbjqz\u0087\u008e\u0096\u00be")
        buf.write("\u00c9")
        return buf.getvalue()


class sxlParser ( Parser ):

    grammarFileName = "sxl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'blocks'", "'{'", "'}'", "'registers'", 
                     "'signals'", "'enums'", "'desc'", "'addr'", "'size'", 
                     "'value'", "'notify'", "'rw'", "'ro'", "'wo'", "'unit'", 
                     "'-'", "'Perc.'", "'numrep'", "'uint8'", "'uint16'", 
                     "'uint32'", "'sint8'", "'sint16'", "'sint32'", "'ufix8.8'", 
                     "'enum'", "'bool'", "'raw'", "'range'", "'pos'", "'mode'", 
                     "'t'", "'c'", "'reset'", "'type'", "'flag'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "Fix_range", "Nat_range", "Int_range", 
                      "HEX", "Fixpoint", "Positive", "Natural", "Integer", 
                      "LABEL", "EXT_LABEL", "STRING", "WS" ]

    RULE_blocks = 0
    RULE_block = 1
    RULE_block_item = 2
    RULE_registers = 3
    RULE_register = 4
    RULE_register_item = 5
    RULE_signals = 6
    RULE_signal = 7
    RULE_signal_item = 8
    RULE_enumeration = 9
    RULE_enum_item = 10
    RULE_description = 11
    RULE_address = 12
    RULE_size = 13
    RULE_value = 14
    RULE_notify = 15
    RULE_unit = 16
    RULE_unit_value = 17
    RULE_numrep = 18
    RULE_numrep_value = 19
    RULE_range_item = 20
    RULE_range_value = 21
    RULE_position = 22
    RULE_position_value = 23
    RULE_sigmode = 24
    RULE_resetval = 25
    RULE_resetval_value = 26
    RULE_type_item = 27
    RULE_type_val = 28

    ruleNames =  [ "blocks", "block", "block_item", "registers", "register", 
                   "register_item", "signals", "signal", "signal_item", 
                   "enumeration", "enum_item", "description", "address", 
                   "size", "value", "notify", "unit", "unit_value", "numrep", 
                   "numrep_value", "range_item", "range_value", "position", 
                   "position_value", "sigmode", "resetval", "resetval_value", 
                   "type_item", "type_val" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    Fix_range=37
    Nat_range=38
    Int_range=39
    HEX=40
    Fixpoint=41
    Positive=42
    Natural=43
    Integer=44
    LABEL=45
    EXT_LABEL=46
    STRING=47
    WS=48

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class BlocksContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.BlockContext)
            else:
                return self.getTypedRuleContext(sxlParser.BlockContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_blocks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlocks" ):
                listener.enterBlocks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlocks" ):
                listener.exitBlocks(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlocks" ):
                return visitor.visitBlocks(self)
            else:
                return visitor.visitChildren(self)




    def blocks(self):

        localctx = sxlParser.BlocksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_blocks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(sxlParser.T__0)
            self.state = 59
            self.match(sxlParser.T__1)
            self.state = 61 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 60
                self.block()
                self.state = 63 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==sxlParser.LABEL):
                    break

            self.state = 65
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(sxlParser.LABEL, 0)

        def block_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.Block_itemContext)
            else:
                return self.getTypedRuleContext(sxlParser.Block_itemContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = sxlParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.match(sxlParser.LABEL)
            self.state = 68
            self.match(sxlParser.T__1)
            self.state = 70 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 69
                self.block_item()
                self.state = 72 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__3) | (1 << sxlParser.T__6) | (1 << sxlParser.T__7) | (1 << sxlParser.T__8))) != 0)):
                    break

            self.state = 74
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Block_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def description(self):
            return self.getTypedRuleContext(sxlParser.DescriptionContext,0)


        def address(self):
            return self.getTypedRuleContext(sxlParser.AddressContext,0)


        def size(self):
            return self.getTypedRuleContext(sxlParser.SizeContext,0)


        def registers(self):
            return self.getTypedRuleContext(sxlParser.RegistersContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_block_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_item" ):
                listener.enterBlock_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_item" ):
                listener.exitBlock_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_item" ):
                return visitor.visitBlock_item(self)
            else:
                return visitor.visitChildren(self)




    def block_item(self):

        localctx = sxlParser.Block_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_block_item)
        try:
            self.state = 80
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sxlParser.T__6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 76
                self.description()
                pass
            elif token in [sxlParser.T__7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 77
                self.address()
                pass
            elif token in [sxlParser.T__8]:
                self.enterOuterAlt(localctx, 3)
                self.state = 78
                self.size()
                pass
            elif token in [sxlParser.T__3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 79
                self.registers()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegistersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def register(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.RegisterContext)
            else:
                return self.getTypedRuleContext(sxlParser.RegisterContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_registers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegisters" ):
                listener.enterRegisters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegisters" ):
                listener.exitRegisters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegisters" ):
                return visitor.visitRegisters(self)
            else:
                return visitor.visitChildren(self)




    def registers(self):

        localctx = sxlParser.RegistersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_registers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.match(sxlParser.T__3)
            self.state = 83
            self.match(sxlParser.T__1)
            self.state = 85 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 84
                self.register()
                self.state = 87 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==sxlParser.LABEL):
                    break

            self.state = 89
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegisterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(sxlParser.LABEL, 0)

        def register_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.Register_itemContext)
            else:
                return self.getTypedRuleContext(sxlParser.Register_itemContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_register

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegister" ):
                listener.enterRegister(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegister" ):
                listener.exitRegister(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegister" ):
                return visitor.visitRegister(self)
            else:
                return visitor.visitChildren(self)




    def register(self):

        localctx = sxlParser.RegisterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_register)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.match(sxlParser.LABEL)
            self.state = 92
            self.match(sxlParser.T__1)
            self.state = 94 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 93
                self.register_item()
                self.state = 96 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__4) | (1 << sxlParser.T__6) | (1 << sxlParser.T__7) | (1 << sxlParser.T__10))) != 0)):
                    break

            self.state = 98
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Register_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sxlParser.RULE_register_item

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegNotifyContext(Register_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Register_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def notify(self):
            return self.getTypedRuleContext(sxlParser.NotifyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegNotify" ):
                listener.enterRegNotify(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegNotify" ):
                listener.exitRegNotify(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegNotify" ):
                return visitor.visitRegNotify(self)
            else:
                return visitor.visitChildren(self)


    class RegDescriptionContext(Register_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Register_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def description(self):
            return self.getTypedRuleContext(sxlParser.DescriptionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegDescription" ):
                listener.enterRegDescription(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegDescription" ):
                listener.exitRegDescription(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegDescription" ):
                return visitor.visitRegDescription(self)
            else:
                return visitor.visitChildren(self)


    class RegSignalsContext(Register_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Register_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def signals(self):
            return self.getTypedRuleContext(sxlParser.SignalsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegSignals" ):
                listener.enterRegSignals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegSignals" ):
                listener.exitRegSignals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegSignals" ):
                return visitor.visitRegSignals(self)
            else:
                return visitor.visitChildren(self)


    class RegAddrContext(Register_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Register_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def address(self):
            return self.getTypedRuleContext(sxlParser.AddressContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegAddr" ):
                listener.enterRegAddr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegAddr" ):
                listener.exitRegAddr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegAddr" ):
                return visitor.visitRegAddr(self)
            else:
                return visitor.visitChildren(self)



    def register_item(self):

        localctx = sxlParser.Register_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_register_item)
        try:
            self.state = 104
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sxlParser.T__6]:
                localctx = sxlParser.RegDescriptionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 100
                self.description()
                pass
            elif token in [sxlParser.T__7]:
                localctx = sxlParser.RegAddrContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.address()
                pass
            elif token in [sxlParser.T__4]:
                localctx = sxlParser.RegSignalsContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 102
                self.signals()
                pass
            elif token in [sxlParser.T__10]:
                localctx = sxlParser.RegNotifyContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 103
                self.notify()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SignalsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.SignalContext)
            else:
                return self.getTypedRuleContext(sxlParser.SignalContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_signals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignals" ):
                listener.enterSignals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignals" ):
                listener.exitSignals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignals" ):
                return visitor.visitSignals(self)
            else:
                return visitor.visitChildren(self)




    def signals(self):

        localctx = sxlParser.SignalsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_signals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(sxlParser.T__4)
            self.state = 107
            self.match(sxlParser.T__1)
            self.state = 109 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 108
                self.signal()
                self.state = 111 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==sxlParser.LABEL):
                    break

            self.state = 113
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SignalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(sxlParser.LABEL, 0)

        def signal_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.Signal_itemContext)
            else:
                return self.getTypedRuleContext(sxlParser.Signal_itemContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_signal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignal" ):
                listener.enterSignal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignal" ):
                listener.exitSignal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal" ):
                return visitor.visitSignal(self)
            else:
                return visitor.visitChildren(self)




    def signal(self):

        localctx = sxlParser.SignalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_signal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.match(sxlParser.LABEL)
            self.state = 116
            self.match(sxlParser.T__1)
            self.state = 118 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 117
                self.signal_item()
                self.state = 120 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__5) | (1 << sxlParser.T__6) | (1 << sxlParser.T__14) | (1 << sxlParser.T__17) | (1 << sxlParser.T__28) | (1 << sxlParser.T__29) | (1 << sxlParser.T__30) | (1 << sxlParser.T__33) | (1 << sxlParser.T__34))) != 0)):
                    break

            self.state = 122
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Signal_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sxlParser.RULE_signal_item

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SigResetContext(Signal_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Signal_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def resetval(self):
            return self.getTypedRuleContext(sxlParser.ResetvalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigReset" ):
                listener.enterSigReset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigReset" ):
                listener.exitSigReset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigReset" ):
                return visitor.visitSigReset(self)
            else:
                return visitor.visitChildren(self)


    class SigPositionContext(Signal_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Signal_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position(self):
            return self.getTypedRuleContext(sxlParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigPosition" ):
                listener.enterSigPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigPosition" ):
                listener.exitSigPosition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigPosition" ):
                return visitor.visitSigPosition(self)
            else:
                return visitor.visitChildren(self)


    class DontcareContext(Signal_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Signal_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unit(self):
            return self.getTypedRuleContext(sxlParser.UnitContext,0)

        def numrep(self):
            return self.getTypedRuleContext(sxlParser.NumrepContext,0)

        def range_item(self):
            return self.getTypedRuleContext(sxlParser.Range_itemContext,0)

        def type_item(self):
            return self.getTypedRuleContext(sxlParser.Type_itemContext,0)

        def enumeration(self):
            return self.getTypedRuleContext(sxlParser.EnumerationContext,0)

        def description(self):
            return self.getTypedRuleContext(sxlParser.DescriptionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDontcare" ):
                listener.enterDontcare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDontcare" ):
                listener.exitDontcare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDontcare" ):
                return visitor.visitDontcare(self)
            else:
                return visitor.visitChildren(self)


    class SigModeContext(Signal_itemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Signal_itemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def sigmode(self):
            return self.getTypedRuleContext(sxlParser.SigmodeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigMode" ):
                listener.enterSigMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigMode" ):
                listener.exitSigMode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigMode" ):
                return visitor.visitSigMode(self)
            else:
                return visitor.visitChildren(self)



    def signal_item(self):

        localctx = sxlParser.Signal_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_signal_item)
        try:
            self.state = 133
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sxlParser.T__14]:
                localctx = sxlParser.DontcareContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 124
                self.unit()
                pass
            elif token in [sxlParser.T__17]:
                localctx = sxlParser.DontcareContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 125
                self.numrep()
                pass
            elif token in [sxlParser.T__28]:
                localctx = sxlParser.DontcareContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 126
                self.range_item()
                pass
            elif token in [sxlParser.T__29]:
                localctx = sxlParser.SigPositionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 127
                self.position()
                pass
            elif token in [sxlParser.T__30]:
                localctx = sxlParser.SigModeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 128
                self.sigmode()
                pass
            elif token in [sxlParser.T__33]:
                localctx = sxlParser.SigResetContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 129
                self.resetval()
                pass
            elif token in [sxlParser.T__34]:
                localctx = sxlParser.DontcareContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 130
                self.type_item()
                pass
            elif token in [sxlParser.T__5]:
                localctx = sxlParser.DontcareContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 131
                self.enumeration()
                pass
            elif token in [sxlParser.T__6]:
                localctx = sxlParser.DontcareContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 132
                self.description()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumerationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enum_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sxlParser.Enum_itemContext)
            else:
                return self.getTypedRuleContext(sxlParser.Enum_itemContext,i)


        def getRuleIndex(self):
            return sxlParser.RULE_enumeration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeration" ):
                listener.enterEnumeration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeration" ):
                listener.exitEnumeration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeration" ):
                return visitor.visitEnumeration(self)
            else:
                return visitor.visitChildren(self)




    def enumeration(self):

        localctx = sxlParser.EnumerationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_enumeration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(sxlParser.T__5)
            self.state = 136
            self.match(sxlParser.T__1)
            self.state = 138 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 137
                self.enum_item()
                self.state = 140 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==sxlParser.LABEL):
                    break

            self.state = 142
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(sxlParser.LABEL, 0)

        def value(self):
            return self.getTypedRuleContext(sxlParser.ValueContext,0)


        def description(self):
            return self.getTypedRuleContext(sxlParser.DescriptionContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_enum_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_item" ):
                listener.enterEnum_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_item" ):
                listener.exitEnum_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_item" ):
                return visitor.visitEnum_item(self)
            else:
                return visitor.visitChildren(self)




    def enum_item(self):

        localctx = sxlParser.Enum_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_enum_item)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.match(sxlParser.LABEL)
            self.state = 145
            self.match(sxlParser.T__1)
            self.state = 146
            self.value()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sxlParser.T__6:
                self.state = 147
                self.description()


            self.state = 150
            self.match(sxlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DescriptionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(sxlParser.STRING, 0)

        def getRuleIndex(self):
            return sxlParser.RULE_description

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDescription" ):
                listener.enterDescription(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDescription" ):
                listener.exitDescription(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescription" ):
                return visitor.visitDescription(self)
            else:
                return visitor.visitChildren(self)




    def description(self):

        localctx = sxlParser.DescriptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_description)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(sxlParser.T__6)
            self.state = 153
            self.match(sxlParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AddressContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEX(self):
            return self.getToken(sxlParser.HEX, 0)

        def getRuleIndex(self):
            return sxlParser.RULE_address

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddress" ):
                listener.enterAddress(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddress" ):
                listener.exitAddress(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddress" ):
                return visitor.visitAddress(self)
            else:
                return visitor.visitChildren(self)




    def address(self):

        localctx = sxlParser.AddressContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_address)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self.match(sxlParser.T__7)
            self.state = 156
            self.match(sxlParser.HEX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SizeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEX(self):
            return self.getToken(sxlParser.HEX, 0)

        def getRuleIndex(self):
            return sxlParser.RULE_size

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSize" ):
                listener.enterSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSize" ):
                listener.exitSize(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSize" ):
                return visitor.visitSize(self)
            else:
                return visitor.visitChildren(self)




    def size(self):

        localctx = sxlParser.SizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_size)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(sxlParser.T__8)
            self.state = 159
            self.match(sxlParser.HEX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Positive(self):
            return self.getToken(sxlParser.Positive, 0)

        def Natural(self):
            return self.getToken(sxlParser.Natural, 0)

        def getRuleIndex(self):
            return sxlParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = sxlParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.match(sxlParser.T__9)
            self.state = 162
            _la = self._input.LA(1)
            if not(_la==sxlParser.Positive or _la==sxlParser.Natural):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NotifyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None # Token


        def getRuleIndex(self):
            return sxlParser.RULE_notify

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotify" ):
                listener.enterNotify(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotify" ):
                listener.exitNotify(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotify" ):
                return visitor.visitNotify(self)
            else:
                return visitor.visitChildren(self)




    def notify(self):

        localctx = sxlParser.NotifyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_notify)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(sxlParser.T__10)
            self.state = 165
            localctx.key = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__11) | (1 << sxlParser.T__12) | (1 << sxlParser.T__13))) != 0)):
                localctx.key = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unit_value(self):
            return self.getTypedRuleContext(sxlParser.Unit_valueContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = sxlParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.match(sxlParser.T__14)
            self.state = 168
            self.unit_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unit_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(sxlParser.LABEL, 0)

        def getRuleIndex(self):
            return sxlParser.RULE_unit_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_value" ):
                listener.enterUnit_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_value" ):
                listener.exitUnit_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit_value" ):
                return visitor.visitUnit_value(self)
            else:
                return visitor.visitChildren(self)




    def unit_value(self):

        localctx = sxlParser.Unit_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_unit_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__15) | (1 << sxlParser.T__16) | (1 << sxlParser.LABEL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumrepContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numrep_value(self):
            return self.getTypedRuleContext(sxlParser.Numrep_valueContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_numrep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumrep" ):
                listener.enterNumrep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumrep" ):
                listener.exitNumrep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumrep" ):
                return visitor.visitNumrep(self)
            else:
                return visitor.visitChildren(self)




    def numrep(self):

        localctx = sxlParser.NumrepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_numrep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(sxlParser.T__17)
            self.state = 173
            self.numrep_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Numrep_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sxlParser.RULE_numrep_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumrep_value" ):
                listener.enterNumrep_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumrep_value" ):
                listener.exitNumrep_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumrep_value" ):
                return visitor.visitNumrep_value(self)
            else:
                return visitor.visitChildren(self)




    def numrep_value(self):

        localctx = sxlParser.Numrep_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_numrep_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__18) | (1 << sxlParser.T__19) | (1 << sxlParser.T__20) | (1 << sxlParser.T__21) | (1 << sxlParser.T__22) | (1 << sxlParser.T__23) | (1 << sxlParser.T__24) | (1 << sxlParser.T__25) | (1 << sxlParser.T__26) | (1 << sxlParser.T__27))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def range_value(self):
            return self.getTypedRuleContext(sxlParser.Range_valueContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_range_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRange_item" ):
                listener.enterRange_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRange_item" ):
                listener.exitRange_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRange_item" ):
                return visitor.visitRange_item(self)
            else:
                return visitor.visitChildren(self)




    def range_item(self):

        localctx = sxlParser.Range_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_range_item)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(sxlParser.T__28)
            self.state = 178
            self.range_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Nat_range(self):
            return self.getToken(sxlParser.Nat_range, 0)

        def Int_range(self):
            return self.getToken(sxlParser.Int_range, 0)

        def Fix_range(self):
            return self.getToken(sxlParser.Fix_range, 0)

        def getRuleIndex(self):
            return sxlParser.RULE_range_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRange_value" ):
                listener.enterRange_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRange_value" ):
                listener.exitRange_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRange_value" ):
                return visitor.visitRange_value(self)
            else:
                return visitor.visitChildren(self)




    def range_value(self):

        localctx = sxlParser.Range_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_range_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__15) | (1 << sxlParser.Fix_range) | (1 << sxlParser.Nat_range) | (1 << sxlParser.Int_range))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def position_value(self):
            return self.getTypedRuleContext(sxlParser.Position_valueContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition" ):
                listener.enterPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition" ):
                listener.exitPosition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosition" ):
                return visitor.visitPosition(self)
            else:
                return visitor.visitChildren(self)




    def position(self):

        localctx = sxlParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_position)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(sxlParser.T__29)
            self.state = 183
            self.position_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Position_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sxlParser.RULE_position_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PosSingleContext(Position_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Position_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Positive(self):
            return self.getToken(sxlParser.Positive, 0)
        def Natural(self):
            return self.getToken(sxlParser.Natural, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosSingle" ):
                listener.enterPosSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosSingle" ):
                listener.exitPosSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosSingle" ):
                return visitor.visitPosSingle(self)
            else:
                return visitor.visitChildren(self)


    class PosRangeContext(Position_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Position_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Nat_range(self):
            return self.getToken(sxlParser.Nat_range, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosRange" ):
                listener.enterPosRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosRange" ):
                listener.exitPosRange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosRange" ):
                return visitor.visitPosRange(self)
            else:
                return visitor.visitChildren(self)



    def position_value(self):

        localctx = sxlParser.Position_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_position_value)
        try:
            self.state = 188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sxlParser.Positive]:
                localctx = sxlParser.PosSingleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 185
                self.match(sxlParser.Positive)
                pass
            elif token in [sxlParser.Natural]:
                localctx = sxlParser.PosSingleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 186
                self.match(sxlParser.Natural)
                pass
            elif token in [sxlParser.Nat_range]:
                localctx = sxlParser.PosRangeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 187
                self.match(sxlParser.Nat_range)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SigmodeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None # Token


        def getRuleIndex(self):
            return sxlParser.RULE_sigmode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigmode" ):
                listener.enterSigmode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigmode" ):
                listener.exitSigmode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigmode" ):
                return visitor.visitSigmode(self)
            else:
                return visitor.visitChildren(self)




    def sigmode(self):

        localctx = sxlParser.SigmodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_sigmode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(sxlParser.T__30)
            self.state = 191
            localctx.key = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sxlParser.T__11) | (1 << sxlParser.T__12) | (1 << sxlParser.T__13) | (1 << sxlParser.T__31) | (1 << sxlParser.T__32))) != 0)):
                localctx.key = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResetvalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resetval_value(self):
            return self.getTypedRuleContext(sxlParser.Resetval_valueContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_resetval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResetval" ):
                listener.enterResetval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResetval" ):
                listener.exitResetval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetval" ):
                return visitor.visitResetval(self)
            else:
                return visitor.visitChildren(self)




    def resetval(self):

        localctx = sxlParser.ResetvalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_resetval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(sxlParser.T__33)
            self.state = 194
            self.resetval_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Resetval_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sxlParser.RULE_resetval_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ResetHexContext(Resetval_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Resetval_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HEX(self):
            return self.getToken(sxlParser.HEX, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResetHex" ):
                listener.enterResetHex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResetHex" ):
                listener.exitResetHex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetHex" ):
                return visitor.visitResetHex(self)
            else:
                return visitor.visitChildren(self)


    class ResetIntContext(Resetval_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sxlParser.Resetval_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Positive(self):
            return self.getToken(sxlParser.Positive, 0)
        def Natural(self):
            return self.getToken(sxlParser.Natural, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResetInt" ):
                listener.enterResetInt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResetInt" ):
                listener.exitResetInt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetInt" ):
                return visitor.visitResetInt(self)
            else:
                return visitor.visitChildren(self)



    def resetval_value(self):

        localctx = sxlParser.Resetval_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_resetval_value)
        try:
            self.state = 199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sxlParser.Positive]:
                localctx = sxlParser.ResetIntContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 196
                self.match(sxlParser.Positive)
                pass
            elif token in [sxlParser.Natural]:
                localctx = sxlParser.ResetIntContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 197
                self.match(sxlParser.Natural)
                pass
            elif token in [sxlParser.HEX]:
                localctx = sxlParser.ResetHexContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 198
                self.match(sxlParser.HEX)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_val(self):
            return self.getTypedRuleContext(sxlParser.Type_valContext,0)


        def getRuleIndex(self):
            return sxlParser.RULE_type_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_item" ):
                listener.enterType_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_item" ):
                listener.exitType_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_item" ):
                return visitor.visitType_item(self)
            else:
                return visitor.visitChildren(self)




    def type_item(self):

        localctx = sxlParser.Type_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_type_item)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(sxlParser.T__34)
            self.state = 202
            self.type_val()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_valContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sxlParser.RULE_type_val

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_val" ):
                listener.enterType_val(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_val" ):
                listener.exitType_val(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_val" ):
                return visitor.visitType_val(self)
            else:
                return visitor.visitChildren(self)




    def type_val(self):

        localctx = sxlParser.Type_valContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_type_val)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            _la = self._input.LA(1)
            if not(_la==sxlParser.T__25 or _la==sxlParser.T__35):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





